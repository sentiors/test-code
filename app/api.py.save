from flask import Flask, request, jsonify, render_template, make_response
import os
import json
from .utils import check_gitlab_pipeline
from .database import db_session, init_db
from .models import User, Lab, GradingResult
from datetime import datetime
import pytz
wib = pytz.timezone("Asia/Jakarta")
timestamp = datetime.now(wib)
import csv
from io import StringIO
import subprocess

app = Flask(__name__)

SCHEME_PATH = "/opt/grading/app/schemes/"
GITLAB_URL = "https://gitlab.smkn1cibinong.sch.id"
ACTIVE_LABS = {}

def get_latest_pipeline(project_id, ref="main"):
    url = f"{GITLAB_URL}/api/v4/projects/{project_id}/pipelines"
    headers = {"Authorization": f"Bearer {GITLAB_TOKEN}"}

    r = requests.get(url, headers=headers, params={"ref": ref})
    return r.json()[0]


def sync_labs_from_schemes():
    """
    Sinkronkan tabel 'labs' dengan semua file JSON di SCHEME_PATH.
    lab_id = nama file tanpa ekstensi .json
    """
    scheme_files = glob.glob(os.path.join(SCHEME_PATH, "*.json"))

    # Ambil lab_id yang sudah ada di DB
    existing = {lab.lab_id for lab in db_session.query(Lab.lab_id).all()}

    for path in scheme_files:
        filename = os.path.basename(path)
        lab_id, ext = os.path.splitext(filename)
        if ext != ".json":
            continue
        if lab_id not in existing:
            db_session.add(Lab(lab_id=lab_id, scheme_path=path))
            existing.add(lab_id)

    db_session.commit()

def run_cleanup_actions(lab_id):
    scheme_file = os.path.join(SCHEME_PATH, f"{lab_id}.json")
    if not os.path.exists(scheme_file):
        return

    with open(scheme_file, "r") as f:
        scheme = json.load(f)

    for criterion in scheme.get("criteria", []):
        ctype = criterion.get("type")
        key = criterion.get("key")
        cleanup = criterion.get("cleanup")

        if not cleanup:
            continue

        try:
            if ctype == "user":
                username = key
                subprocess.run(["userdel", "-r", username], check=False)
        except Exception as e:
            print(f"Cleanup error for {lab_id} {ctype} {key}: {e}")


@app.before_request
def validate_content_type():
    if request.method == 'POST' and not request.is_json:
        return jsonify({"error": "Content-Type must be application/json"}), 415

@app.route('/register', methods=['POST'])
def register():
    try:
        data = request.json
        name = data.get("name")
        group_name = data.get("group_name")
        username = data.get("username")
        password = data.get("password")
        class_name = data.get("class_name")

        # Validasi input
        if not username or not password or not name or not class_name or not group_name:
            return jsonify({"error": "Username, password, name, class_name, and group_name are required"}), 400

        # Cek apakah username sudah ada
        existing_user = db_session.query(User).filter(User.username == username).first()
        if existing_user:
            return jsonify({"error": "Username already exists"}), 400

        # Buat user baru
        new_user = User(name=name, group_name=group_name, username=username, password=password, class_name=class_name)
        db_session.add(new_user)
        db_session.commit()

        return jsonify({"message": "User registered successfully"}), 201

    except Exception as e:
        print(f"Error in register: {str(e)}")  # Debugging
        db_session.rollback()
        return jsonify({"error": "Server error", "details": str(e)}), 500

@app.route('/login', methods=['POST'])
def login():
    try:
        data = request.json
        username = data.get("username")
        password = data.get("password")

        # Validasi input
        if not username or not password:
            return jsonify({"error": "Username and password are required"}), 400

        # Cari user di database
        user = db_session.query(User).filter(User.username == username).first()
        if not user:
            return jsonify({"error": "User not exist, please register first (gradingctl register)"}), 404

        # Validasi password
        if user.password != password:
            return jsonify({"error": "Invalid password"}), 401

        # Buat token (contoh sederhana)
        token = f"dummy-token-{username}-{user.class_name}"
        return jsonify({"token": token, "class_name": user.class_name}), 200

    except Exception as e:
        print(f"Error in login: {str(e)}")  # Debugging
        return jsonify({"error": "Server error", "details": str(e)}), 500

@app.route('/start-lab', methods=['POST'])
def start_lab():
    try:
        # Ambil token dari header Authorization
        auth_header = request.headers.get("Authorization")
        if not auth_header or not auth_header.startswith("Bearer "):
            return jsonify({"error": "Invalid or missing Authorization header"}), 401

        token = auth_header.split("Bearer ")[-1]
        if not token:
            return jsonify({"error": "Token is missing"}), 401

        # Ambil lab_id dari body request
        data = request.get_json()
        if not data or "lab_id" not in data:
            return jsonify({"error": "Invalid request data"}), 400

        lab_id = data.get("lab_id")
        scheme_file = os.path.join(SCHEME_PATH, f"{lab_id}.json")

        # Periksa apakah file skema lab ada
        if not os.path.exists(scheme_file):
            return jsonify({"error": f"Lab '{lab_id}' not found"}), 404

        from datetime import datetime
        import pytz
        wib = pytz.timezone("Asia/Jakarta")
        start_time = datetime.now(wib)

        # Simpan lab yang aktif untuk token ini
        ACTIVE_LABS[token] = {"lab_id": lab_id, "status": "active", "start_time": start_time}

        return jsonify({"message": f"Lab '{lab_id}' started successfully"}), 200

    except Exception as e:
        print(f"Error in start_lab: {str(e)}")  # Debugging
        return jsonify({"error": "Server error", "details": str(e)}), 500

@app.route('/get-scheme-description', methods=['GET'])
def get_scheme_description():
    lab_id = request.args.get("lab_id")
    scheme_file = os.path.join(SCHEME_PATH, f"{lab_id}.json")

    if not os.path.exists(scheme_file):
        return jsonify({"error": "Lab not found"}), 404

    with open(scheme_file, 'r') as f:
        scheme = json.load(f)

    # Format deskripsi skema
    description = {
        "lab_id": lab_id,
        "description": scheme.get("description", "No description available"),
        "criteria": [
            {
                "type": criterion.get("type"),
                "description": criterion.get("description"),
                "key": criterion.get("key")
            }
            for criterion in scheme.get("criteria", [])
        ]
    }

    return jsonify(description), 200

@app.route('/get-scheme', methods=['GET'])
def get_scheme():
    lab_id = request.args.get("lab_id")
    scheme_file = os.path.join(SCHEME_PATH, f"{lab_id}.json")

    if not os.path.exists(scheme_file):
        return jsonify({"error": "Lab not found"}), 404

    with open(scheme_file, 'r') as f:
        scheme = json.load(f)

    return jsonify({"scheme": scheme}), 200

from datetime import datetime
import pytz
wib = pytz.timezone("Asia/Jakarta")

@app.route('/grade-lab', methods=['POST'])
def grade_lab():
    try:
        # Ambil token dan body
        token = request.headers.get("Authorization", "").replace("Bearer ", "")
        data = request.get_json()
        print("FULL DATA POSTED:", data)

        if not data:
            return jsonify({"error": "Invalid request data"}), 400

        lab_id = data.get("lab_id")
        class_name = data.get("class_name")
        client_data = data.get("client_data", {})

        lab_log_path = f"/var/log/gradingctl/labs/{lab_id}.log"
        os.makedirs(os.path.dirname(lab_log_path), exist_ok=True)

        if not lab_id or not class_name:
            return jsonify({"error": "lab_id and class_name are required"}), 400

        # Ambil username dari token
        username = token.split("-")[2]
        print(f"Username: {username}, Class Name: {class_name}")

        if not isinstance(client_data, dict):
            return jsonify({"error": "Invalid client data format"}), 400

        # Validasi / inisialisasi lab aktif
        active_lab_map = ACTIVE_LABS.setdefault(token, {})
        # Kalau belum ada / beda lab_id, inisialisasi baru
        if not lab_id or active_lab_map:
            active_lab_map[lab_id] = {
#                "lab_id": lab_id,
                "start_time": datetime.now(wib)
            }
            active_lab = active_lab_map[lab_id]

        # Baca scheme
        scheme_file = os.path.join(SCHEME_PATH, f"{lab_id}.json")
        if not os.path.exists(scheme_file):
            return jsonify({"error": "Lab not found"}), 404

        with open(scheme_file, 'r') as f:
            scheme = json.load(f)

        total_score = 0
        feedback_failed = []
        feedback_success = []

        # ========= LOGIKA PENILAIAN PER KRITERIA =========
        for criterion in scheme.get("criteria", []):
            ctype = criterion.get("type")
            key = criterion.get("key")
            expected = criterion.get("expected")
            description = criterion.get("description")
            score = criterion.get("score", 0)

            actual_value = client_data.get(key, None)

            failed = False
            if actual_value is None or actual_value == "":
                failed = True
            elif ctype == "command":
                if str(actual_value) != str(expected):
                    failed = True
            elif ctype == "file_exists":
                if expected != str(actual_value):
                    failed = True
            elif ctype == "file_content":
                contains = criterion.get("contains")
                if not (contains and contains in str(actual_value)):
                    failed = True
            elif ctype == "service":
                if expected != str(actual_value):
                    failed = True
            elif ctype == "directory":
                if expected != str(actual_value):
                    failed = True
            elif ctype == "config_check":
                if not (expected and str(actual_value) == "correct"):
                    failed = True
            elif ctype == "package":
                if expected != str(actual_value):
                    failed = True
            elif ctype == "user":
                if expected != str(actual_value):
                    failed = True
            elif ctype == "group":
                if expected != str(actual_value):
                    failed = True
            elif ctype == "gitlab_pipeline":
                if expected != str(actual_value):
                    failed = True
            elif ctype == "gitlab_project_exists":

            if not failed:
                total_score += score
                feedback_success.append(description)
            else:
                feedback_failed.append(f"{description}: Failed")
                with open(lab_log_path, 'a') as logfile:
                    logfile.write(f"[{datetime.now(wib)}] CASE: {description} | ERROR: {actual_value}\n")

        # Kalau ada minimal 1 failed, nilai 0
        #if any("Failed" in f for f in feedback_failed):
        #    total_score = 0

        # Gabungkan: gagal dulu, lalu yang sukses
        all_feedback = feedback_failed + feedback_success

        print("DEBUG feedback_failed:", feedback_failed)
        print("DEBUG feedback_success:", feedback_success)
        print("DEBUG all_feedback:", all_feedback)
        print(f"Total score calculated: {total_score}")

        try:
            # Hitung durasi
            start_time = active_lab.get("start_time")
            end_time = datetime.now(wib)
            duration = (end_time - start_time).total_seconds() if start_time else None

            # Penalty waktu (min 80, hanya kalau nilai > 0)
            max_duration = 180   # 3 menit (detik)
            penalty_percent = 5
            min_score = 80
            penalty_messages = []
            score_awal = total_score

            if total_score > 0 and duration is not None and duration > max_duration:
                n_penalty = int((duration - max_duration) // max_duration) + 1
                penalty_total = n_penalty * penalty_percent
                new_score = score_awal * (100 - penalty_total) / 100
                if new_score < min_score:
                    new_score = min_score
                total_score = new_score
                penalty_messages.append(
                    f"Waktu pengerjaan melebihi 3 menit, pengurangan {penalty_percent}% per 3 menit. Nilai akhir: {new_score:.2f}"
                )

            # Ambil info user dan grup
            user_info = db_session.query(User).filter_by(username=username).first()
            if not user_info:
                return jsonify({"error": "User not found"}), 404

            group_name = user_info.group_name
            class_name = user_info.class_name

            group_users = db_session.query(User).filter_by(class_name=class_name, group_name=group_name).all()

            # Simpan hasil ke semua anggota grup
            for group_user in group_users:
                grading_result = GradingResult(
                    username=group_user.username,
                    class_name=class_name,
                    lab_id=lab_id,
                    score=total_score,
                    feedback=", ".join(all_feedback),
                    duration=duration,
                    status="done",
                    timestamp=datetime.now(wib)
                )
                db_session.add(grading_result)

            db_session.commit()

            print(f"Data saved for group '{group_name}': {[u.username for u in group_users]}, lab: {lab_id}, score: {total_score}")

        except Exception as db_error:
            print(f"Database Error: {str(db_error)}")
            db_session.rollback()

        return jsonify({
            "score": total_score if total_score is not None else 0,
            "feedback": all_feedback if isinstance(all_feedback, list) else [],
            "log_path": lab_log_path,
            "duration": duration if duration is not None else 0,
            "penalty": penalty_messages
        }), 200

    except json.JSONDecodeError as e:
        print(f"JSON Decode Error: {str(e)}")
        return jsonify({"error": "Invalid JSON format", "details": str(e)}), 400
    except Exception as e:
        print(f"Error: {str(e)}")
        return jsonify({"error": "Server error", "details": str(e)}), 500

@app.route('/finish-lab', methods=['POST'])
def finish_lab():
    try:
        auth_header = request.headers.get("Authorization")
        if not auth_header or not auth_header.startswith("Bearer "):
            return jsonify({"error": "Invalid or missing Authorization header"}), 401

        token = auth_header.split("Bearer ")[-1]
        if not token:
            return jsonify({"error": "Token is missing"}), 401

        data = request.get_json()
        if not data or "lab_id" not in data:
            return jsonify({"error": "Invalid request data"}), 400

        lab_id = data.get("lab_id")

        # kalau masih tercatat aktif, hapus dari ACTIVE_LABS
        active_lab = ACTIVE_LABS.get(token)
        if active_lab and active_lab.get("lab_id") == lab_id:
            del ACTIVE_LABS[token]

        # jalankan cleanup sesuai skema
        run_cleanup_actions(lab_id)

        # hapus log kalau ada
        lab_log_path = f"/var/log/gradingctl/labs/{lab_id}.log"
        if os.path.exists(lab_log_path):
            os.remove(lab_log_path)

        return jsonify({"message": f"Lab '{lab_id}' finished successfully"}), 200

    except Exception as e:
        print(f"Error in finish_lab: {str(e)}")
        return jsonify({"error": "Server error", "details": str(e)}), 500

@app.route('/add-lab', methods=['POST'])
def add_lab():
    try:
        data = request.json
        lab_id = data.get("lab_id")
        scheme_path = data.get("scheme_path")

        if not lab_id or not scheme_path:
            return jsonify({"error": "lab_id and scheme_path are required"}), 400

        # Cek apakah lab sudah ada
        existing_lab = db_session.query(Lab).filter(Lab.lab_id == lab_id).first()
        if existing_lab:
            return jsonify({"error": "Lab already exists"}), 400

        # Buat lab baru
        new_lab = Lab(lab_id=lab_id, scheme_path=scheme_path)
        db_session.add(new_lab)
        db_session.commit()

        return jsonify({"message": "Lab added successfully"}), 201

    except Exception as e:
        print(f"Error in add-lab: {str(e)}")  # Debugging
        db_session.rollback()
        return jsonify({"error": "Server error", "details": str(e)}), 500

@app.route('/list-labs', methods=['GET'])
def list_labs():
    try:
        labs = db_session.query(Lab).all()
        lab_list = [{"lab_id": lab.lab_id, "scheme_path": lab.scheme_path} for lab in labs]
        return jsonify({"labs": lab_list}), 200
    except Exception as e:
        print(f"Error in list-labs: {str(e)}")  # Debugging
        return jsonify({"error": "Server error", "details": str(e)}), 500

@app.route('/delete-lab', methods=['POST'])
def delete_lab():
    try:
        data = request.json
        lab_id = data.get("lab_id")

        if not lab_id:
            return jsonify({"error": "lab_id is required"}), 400

        # Cari lab berdasarkan ID
        lab = db_session.query(Lab).filter(Lab.lab_id == lab_id).first()
        if not lab:
            return jsonify({"error": "Lab not found"}), 404

        # Hapus lab
        db_session.delete(lab)
        db_session.commit()

        return jsonify({"message": f"Lab '{lab_id}' deleted successfully"}), 200

    except Exception as e:
        print(f"Error in delete-lab: {str(e)}")  # Debugging
        db_session.rollback()
        return jsonify({"error": "Server error", "details": str(e)}), 500

@app.route('/users-not-started-lab-filtered', methods=['GET'])
def users_not_started_lab_filtered():
    try:
        class_name = request.args.get("class_name")
        lab_id = request.args.get("lab_id")

        # Ambil semua user yang sudah memulai lab tertentu
        users_started_lab = db_session.query(GradingResult.username).filter(GradingResult.lab_id == lab_id).all()
        users_started_lab = [user[0] for user in users_started_lab]

        # Ambil semua user berdasarkan class_name (jika ada filter class_name)
        query = db_session.query(User)
        if class_name:
            query = query.filter(User.class_name == class_name)
        all_users = query.all()

        # Filter user yang belum memulai lab
        users_not_started = [user.username for user in all_users if user.username not in users_started_lab]

        return jsonify({
            "users_not_started": users_not_started,
            "class_name": class_name,
            "lab_id": lab_id
        }), 200
    except Exception as e:
        print(f"Error in users-not-started-lab-filtered: {str(e)}")
        return jsonify({"error": "Failed to fetch users not started lab", "details": str(e)}), 500

@app.route('/users-not-started-lab', methods=['GET'])
def users_not_started_lab():
    try:
        lab_id = request.args.get("lab_id")

        if not lab_id:
            return jsonify({"error": "lab_id is required"}), 400

        # Ambil semua user yang belum memulai lab ini
        users_started_lab = db_session.query(GradingResult.username).filter(GradingResult.lab_id == lab_id).all()
        users_started_lab = [user[0] for user in users_started_lab]

        # Ambil semua user yang belum memulai lab
        all_users = db_session.query(User.username).all()
        all_users = [user[0] for user in all_users]

        users_not_started = list(set(all_users) - set(users_started_lab))

        return jsonify({"users_not_started": users_not_started}), 200

    except Exception as e:
        print(f"Error in users-not-started-lab: {str(e)}")  # Debugging
        return jsonify({"error": "Server error", "details": str(e)}), 500

@app.route('/get-users-and-labs', methods=['GET'])
def get_users_and_labs():
    try:
        # Ambil semua user dari tabel users
        users = db_session.query(User).all()
        user_list = [
            {
                "username": user.username,
                "class_name": user.class_name,
                "name": user.name,
                "group_name": user.group_name
            }
            for user in users
        ]

        # Ambil semua lab dari tabel labs
        labs = db_session.query(Lab).all()
        lab_list = [{"lab_id": lab.lab_id} for lab in labs]

        # Ambil semua user yang sudah memulai lab dari tabel grading_results
        users_started_lab = db_session.query(GradingResult.username).distinct().all()
        users_started_lab = [user[0] for user in users_started_lab]

        return jsonify({
            "users": user_list,
            "labs": lab_list,
            "users_started_lab": users_started_lab
        }), 200
    except Exception as e:
        print(f"Error fetching users and labs: {str(e)}")
        return jsonify({"error": "Failed to fetch users and labs", "details": str(e)}), 500

@app.route('/results', methods=['GET'])
def show_results():
    try:
        class_name = request.args.get("class_name")
        lab_id = request.args.get("lab_id")
        search_name = request.args.get("search_name")
        page = int(request.args.get("page", 1))
        per_page = 10

        # Ambil data dari tabel users dan labs
        users = db_session.query(User).all()
        labs = db_session.query(Lab).all()

        # Ambil data dari tabel grading_results dengan filter
        query = (
            db_session.query(GradingResult)
            .join(User, User.username == GradingResult.username)
        )

        if class_name:
            query = query.filter(GradingResult.class_name == class_name)
        if lab_id:
            query = query.filter(GradingResult.lab_id == lab_id)
        if search_name:
            query = query.filter(User.name.ilike(f"%{search_name}%"))

        total_results = query.count()
        results = query.offset((page - 1) * per_page).limit(per_page).all()

        from datetime import timedelta
        for result in results:
            if result.timestamp:
                result.local_timestamp = result.timestamp + timedelta(hours=7)
            else:
                result.local_timestamp = '-'

        # Ambil user yang belum memulai lab dengan filter
        users_started_lab = db_session.query(GradingResult.username).distinct().all()
        users_started_lab = [user[0] for user in users_started_lab]
        users_not_started_lab = [user.username for user in users if user.username not in users_started_lab]

        return render_template(
            'results.html',
            results=results,
            users=users,
            labs=labs,
            users_not_started_lab=users_not_started_lab,
            class_name=class_name,
            lab_id=lab_id,
            search_name=search_name,
            page=page,
            total_pages=(total_results + per_page - 1) // per_page
        )
    except Exception as e:
        print("Error:", str(e))
        return jsonify({"error": "Failed to fetch results", "details": str(e)}), 500

@app.route('/download-results', methods=['GET'])
def download_results():
    try:
        class_name = request.args.get("class_name", "").strip()
        lab_id = request.args.get("lab_id", "").strip()
        search_name = request.args.get("search_name", "").strip()  # TAMBAH INI

        query = db_session.query(GradingResult)

        # Filter berdasarkan class_name
        if class_name:
            query = query.filter(GradingResult.class_name == class_name)

        # Filter berdasarkan lab_id
        if lab_id:
            query = query.filter(GradingResult.lab_id == lab_id)

        # TAMBAH: Filter berdasarkan user name (search_name)
        if search_name:
            # Join dengan User table untuk filter berdasarkan nama
            query = query.join(User, GradingResult.username == User.username)
            query = query.filter(User.name == search_name)

        results = query.order_by(
            GradingResult.username.asc(),
            GradingResult.lab_id.asc(),
            GradingResult.score.desc()).all()

        print(f"Number of results fetched: {len(results)}")

        users = db_session.query(User).all()

        best_results = {}
        for result in results:
            key = (result.username, result.class_name, result.lab_id)
            if key not in best_results or result.score > best_results[key].score:
                best_results[key] = result

        final_results = list(best_results.values())

        # Buat file CSV dalam memori
        output = StringIO()
        writer = csv.writer(output)

        # Tulis header CSV
        writer.writerow(['Username', 'Nama', 'Kelas', 'Kelompok', 'Lab ID', 'Score', 'Feedback', 'Timestamp'])

        # Tulis data ke CSV
        for result in final_results:
            user = next((u for u in users if u.username == result.username), None)
            writer.writerow([
                result.username,
                user.name if user else '',
                result.class_name,
                user.group_name if user else '',
                result.lab_id,
                result.score,
                result.feedback,
                result.timestamp.strftime('%Y-%m-%d %H:%M:%S')
            ])

        # Siapkan respons untuk mengunduh file CSV
        output.seek(0)
        response = make_response(output.getvalue())
        response.headers['Content-Disposition'] = 'attachment; filename=grading_results.csv'
        response.headers['Content-type'] = 'text/csv'

        return response

    except Exception as e:
        print(f"Error generating CSV: {str(e)}")
        return jsonify({"error": "Failed to generate CSV", "details": str(e)}), 500

@app.route('/get-filters', methods=['GET'])
def get_filters():
    try:
        # Ambil daftar class_name yang unik
        class_names = db_session.query(GradingResult.class_name).distinct().all()
        class_names = [name[0] for name in class_names]

        # Ambil daftar lab_id yang unik
        lab_ids = db_session.query(GradingResult.lab_id).distinct().all()
        lab_ids = [lab_id[0] for lab_id in lab_ids]

        return jsonify({
            "class_names": class_names,
            "lab_ids": lab_ids
        }), 200
    except Exception as e:
        print(f"Error fetching filters: {str(e)}")
        return jsonify({"error": "Failed to fetch filters", "details": str(e)}), 500

@app.route('/delete-result', methods=['POST'])
def delete_result():
    try:
        data = request.get_json()

        if not data or "id" not in data:
            return jsonify({"error": "Invalid request data"}), 400

        result_id = data.get("id")

        # Cari data berdasarkan ID
        result = db_session.query(GradingResult).filter(GradingResult.id == result_id).first()
        if not result:
            return jsonify({"error": "Result not found"}), 404

        # Hapus data dari database
        db_session.delete(result)
        db_session.commit()

        return jsonify({"message": f"Result with ID {result_id} deleted successfully"}), 200

    except Exception as e:
        print(f"Error deleting result: {str(e)}")  # Debugging
        db_session.rollback()
        return jsonify({"error": "Failed to delete result", "details": str(e)}), 500

@app.route('/scheme-editor', methods=['GET'])
def scheme_editor():
    try:
        # Render file scheme_editor.html
        return render_template('scheme_editor.html')
    except Exception as e:
        print(f"Error rendering scheme editor: {str(e)}")  # Debugging
        return jsonify({"error": "Failed to load scheme editor", "details": str(e)}), 500

@app.route('/create_scheme', methods=['GET', 'POST'])
def create_scheme():
    types = ["command", "file_exists", "file_content", "service", "directory", "config_check", "package", "user", "group"]
    expected = {
        "command": ["true", "false"],
        "file_exists": ["exists", "deleted"],
        "file_content": ["contains"],
        "service": ["active", "inactive"],
        "directory": ["exists"],
        "config_check": ["correct"],
        "package": ["installed"],
        "user": ["exists", "deleted"],
        "group": ["exists", "deleted"]
    }

    if request.method == "GET":
        return render_template("add_scheme.html", types=types, expected=expected)

    try:
        data = request.get_json()

        if not data or "lab_id" not in data or "criteria" not in data:
            return jsonify({"error": "Invalid request data"}), 400

        lab_id = data.get("lab_id")
        criteria = data.get("criteria")

        # Validasi kriteria
        if not isinstance(criteria, list) or len(criteria) == 0:
            return jsonify({"error": "At least one criterion is required"}), 400

        # Hitung skor otomatis
        num_criteria = len(criteria)
        score_per_criterion = 100 / num_criteria

        # Update skor untuk setiap kriteria
        for criterion in criteria:
            criterion["score"] = round(score_per_criterion, 2)

        # Buat skema baru
        scheme = {
            "lab_id": lab_id,
            "criteria": criteria
        }

        # Simpan skema ke file
        scheme_file = os.path.join(SCHEME_PATH, f"{lab_id}.json")
        with open(scheme_file, 'w') as f:
            json.dump(scheme, f, indent=4)

        # Tambahkan lab ke database jika belum ada
        existing_lab = db_session.query(Lab).filter(Lab.lab_id == lab_id).first()
        if not existing_lab:
            new_lab = Lab(lab_id=lab_id, scheme_path=scheme_file)
            db_session.add(new_lab)
            db_session.commit()

        return jsonify({"message": f"Scheme '{lab_id}' created successfully"}), 200

    except Exception as e:
        print(f"Error creating scheme: {str(e)}")  # Debugging
        db_session.rollback()
        return jsonify({"error": "Failed to create scheme", "details": str(e)}), 500

@app.route('/edit_scheme', methods=['POST'])
def edit_scheme():
    try:
        data = request.get_json()

        if not data or "lab_id" not in data or "criteria" not in data:
            return jsonify({"error": "Invalid request data"}), 400

        lab_id = data.get("lab_id")
        criteria = data.get("criteria")

        # Hitung skor otomatis
        num_criteria = len(criteria)
        if num_criteria == 0:
            return jsonify({"error": "At least one criterion is required"}), 400

        score_per_criterion = 100 / num_criteria

        # Update skor untuk setiap kriteria
        for criterion in criteria:
            criterion["score"] = round(score_per_criterion, 2)

        # Buat skema baru
        scheme = {
            "lab_id": lab_id,
            "criteria": criteria
        }

        # Simpan skema ke file
        scheme_file = os.path.join(SCHEME_PATH, f"{lab_id}.json")
        with open(scheme_file, 'w') as f:
            json.dump(scheme, f, indent=4)

        # Tambahkan lab ke database jika belum ada
        existing_lab = db_session.query(Lab).filter(Lab.lab_id == lab_id).first()
        if not existing_lab:
            new_lab = Lab(lab_id=lab_id, scheme_path=scheme_file)
            db_session.add(new_lab)
            db_session.commit()

        return jsonify({"message": f"Scheme '{lab_id}' updated successfully"}), 200

    except Exception as e:
        print(f"Error editing scheme: {str(e)}")  # Debugging
        db_session.rollback()
        return jsonify({"error": "Failed to edit scheme", "details": str(e)}), 500

@app.route('/edit_scheme/<lab_id>', methods=['GET'])
def edit_scheme_page(lab_id):
    scheme_file = os.path.join(SCHEME_PATH, f"{lab_id}.json")
    if not os.path.exists(scheme_file):
        return "Scheme not found", 404

    with open(scheme_file, "r") as f:
        scheme = json.load(f)

    types = ["command", "file_exists", "file_content", "service", "directory", "config_check", "package", "user", "group"]

    expected = {
        "command": ["true", "false"],
        "file_exists": ["exists", "deleted"],
        "file_content": ["contains"],
        "service": ["active", "inactive"],
        "directory": ["exists"],
        "config_check": ["correct"],
        "package": ["installed"],
        "user": ["exists", "deleted"],
        "group": ["exists", "deleted"]
    }

    return render_template("edit_scheme.html", scheme=scheme, types=types, expected=expected)

@app.route('/edit_scheme/<lab_id>', methods=['POST'])
def edit_scheme_post(lab_id):
    try:
        data = request.get_json()
        criteria = data.get("criteria")
        # Jika perlu, bisa compare lab_id dari data dan URL, tapi biasanya cukup dari URL
        scheme = {
            "lab_id": lab_id,
            "criteria": criteria
        }
        scheme_file = os.path.join(SCHEME_PATH, f"{lab_id}.json")
        with open(scheme_file, 'w') as f:
            json.dump(scheme, f, indent=4)
        # --- Update database jika perlu ---
        existing_lab = db_session.query(Lab).filter(Lab.lab_id == lab_id).first()
        if existing_lab:
            existing_lab.scheme_path = scheme_file
            db_session.commit()
        return jsonify({"message": f"Scheme '{lab_id}' updated successfully"})
    except Exception as e:
        db_session.rollback()
        return jsonify({"error": "Failed to edit scheme", "details": str(e)}), 500

@app.route('/delete_scheme', methods=['POST'])
def delete_scheme():
    try:
        data = request.get_json()

        if not data or "lab_id" not in data:
            return jsonify({"error": "Invalid request data"}), 400

        lab_id = data.get("lab_id")
        scheme_file = os.path.join(SCHEME_PATH, f"{lab_id}.json")

        if not os.path.exists(scheme_file):
            return jsonify({"error": f"Scheme '{lab_id}' not found"}), 404

        # Hapus file skema
        os.remove(scheme_file)

        # Hapus lab dari database
        lab = db_session.query(Lab).filter(Lab.lab_id == lab_id).first()
        if lab:
            db_session.delete(lab)
            db_session.commit()

        return jsonify({"message": f"Scheme '{lab_id}' deleted successfully"}), 200

    except Exception as e:
        print(f"Error deleting scheme: {str(e)}")  # Debugging
        db_session.rollback()
        return jsonify({"error": "Failed to delete scheme", "details": str(e)}), 500

@app.route('/list-schemes', methods=['GET'])
def list_schemes():
    try:
        schemes = []
        for filename in os.listdir(SCHEME_PATH):
            if filename.endswith(".json"):
                scheme_file = os.path.join(SCHEME_PATH, filename)
                with open(scheme_file, 'r') as f:
                    scheme = json.load(f)
                    schemes.append(scheme)

                    # Tambahkan lab ke database jika belum ada
                    lab_id = scheme.get("lab_id")
                    existing_lab = db_session.query(Lab).filter(Lab.lab_id == lab_id).first()
                    if not existing_lab:
                        new_lab = Lab(lab_id=lab_id, scheme_path=scheme_file)
                        db_session.add(new_lab)
                        db_session.commit()

        return jsonify({"schemes": schemes}), 200

    except Exception as e:
        print(f"Error listing schemes: {str(e)}")  # Debugging
        db_session.rollback()
        return jsonify({"error": "Failed to list schemes", "details": str(e)}), 500

@app.route('/')
def home():
    order_by = request.args.get('order_by', 'name_asc')

    schemes = []
    for filename in os.listdir(SCHEME_PATH):
        if filename.endswith(".json"):
            scheme_file = os.path.join(SCHEME_PATH, filename)
            with open(scheme_file, 'r') as f:
                scheme = json.load(f)

            # kalau lab_id nggak ada di file, ambil dari nama file
            scheme.setdefault('lab_id', filename.replace('.json', ''))
            schemes.append(scheme)

    if order_by == 'name_asc':
        schemes.sort(key=lambda s: s.get('lab_id', '').lower())
    elif order_by == 'name_desc':
        schemes.sort(key=lambda s: s.get('lab_id', '').lower(), reverse=True)

    return render_template('index.html', schemes=schemes, order_by=order_by)

@app.route('/add_scheme')
def add_scheme():
    types = ["command", "file_exists", "file_content", "service", "directory", "config_check", "package", "user", "group", "gitlab_pipeline", "gitlab_project_exists"]
    expected = {
        "command": ["true", "false"],
        "file_exists": ["exists", "deleted"],
        "file_content": ["contains"],
        "service": ["active", "inactive"],
        "directory": ["exists"],
        "config_check": ["correct"],
        "package": ["installed"],
        "user": ["exists", "deleted"],
        "group": ["exists", "deleted"],
        "gitlab_pipeline": ["success"],
        "gitlab_project_exists": ["exists"]
    }

    return render_template('add_scheme.html', types=types, expected=expected)

@app.route('/get-log', methods=['GET'])
def get_log():
    token = request.headers.get("Authorization", "").replace("Bearer ", "")
    lab_id = request.args.get("lab_id")
    # Validasi token/lab jika perlu, misal: cek user, cek status lab
    log_path = f"/var/log/gradingctl/labs/{lab_id}.log"
    try:
        with open(log_path, "r") as f:
            content = f.read()
        return jsonify({"content": content}), 200
    except Exception as e:
        return jsonify({"error": f"Log not found: {str(e)}"}), 404

@app.route("/webhook/gitlab", methods=["POST"])
def gitlab_webhook():
    # 1. Validasi secret token
    if request.headers.get("X-Gitlab-Token") != GITLAB_SECRET:
        return jsonify({"error": "Unauthorized"}), 403

    data = request.json

    # 2. Ambil data penting
    project_id = data["project"]["id"]
    pipeline = data["object_attributes"]

    pipeline_id = pipeline["id"]
    status = pipeline["status"]
    ref = pipeline["ref"]
    sha = pipeline["sha"]

    # 3. Simpan status (cache / DB)
    ACTIVE_PIPELINES[(project_id, ref)] = {
        "pipeline_id": pipeline_id,
        "status": status,
        "sha": sha
    }

    return jsonify({"message": "Pipeline recorded"}), 200


if __name__ == "__main__":
    init_db()
    app.run(host="0.0.0.0", port=5000, debug=True)
